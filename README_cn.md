# 合并有序数组

第一次使用 Rust 写相对完整的程序，可能还有很多可改进的地方（求建议qwq）~

## 题目

给定 n 个满足下述条件的有序 `int64` 数据块（可看作数组）：

- 所有数值服从 **均匀分布**；
- 总数据量大致为 **1TiB**；

需要设计并实现一个将所有有序数据块合并的算法，同时应当尽可能利用多核处理器这一特性，并使用不超过 16GiB 内存。

## 思想

既然值域相对较小 (0 ~ 2^64 - 1)，所以考虑依据值域进行分段处理。

- 将 `[0 .. 2^64 - 1]` 切分成 512 (2^9) 长度相等的*段*。第 i 段记作 `p[i]`，且 `p[i] = [i * 2^55 .. i * 2^56  - 1]`；
- 对于每一*段* `p[i]`：
  - 遍历每一个数据块，筛选出所有大小坐落于 `p[i]` 中的数值，并存放于数组 `a[i]` 中；
  - 数据服从均匀分布，因此数组 `a[i]` 的大小不太可能超过内存限制；
  - 采用多线程排序算法对 `a[i]` 进行排序，然后写回硬盘；
- 按顺序连接硬盘上的所有排序结果。

## 其他可能改进

- 如果数值**不服从**均匀分布，可考虑使用*二分搜索*以确定每一*段*的下限和上限（从而使得每一段的大小尽可能相等，且得以装载入内存）。不过这对于每一个值会带来多余的 O(logn) 次 I/O 操作。


## 测试 & 性能分析

**还没搞完……**

由于测试平台性能的局限性，测试时将数据块的总大小限制在 **256MiB** 左右，并且期望程序占用的内存为 **1MiB** 左右（维持 256 倍关系）。
